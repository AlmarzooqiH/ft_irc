Here’s a focused, next-steps plan based on what’s already in your codebase.

What you already have

Socket setup/listen and a single poll loop in Server::start with implementation in Server.cpp.
Accepting clients into a fixed pollfd array; per-client input buffering; CRLF line splitting; basic “handshake” handler in Server::performHandshake.
Minimal PASS, CAP LS/END, and NICK handling; client state container Client with username/nickname.
High-priority fixes (stability and non-blocking I/O)

Make accepted client sockets non-blocking
After accept in Server::start, set O_NONBLOCK on the returned fd. Do not rely only on MSG_DONTWAIT.
Fix recv buffer overflow and error handling in Server::recieveData
Read at most BUFFER_SIZE-1; handle EAGAIN/EWOULDBLOCK without treating it as an error; treat recv==0 as disconnect.
Handle connection lifecycle in the poll loop in Server.cpp
React to POLLHUP, POLLERR, POLLNVAL; on disconnect/errors: close fd, set clients[i].fd = -1, erase from Server::clientMap and Server::clientBuffer.
If no free poll slot after accept, immediately close the new socket.
Add a per-client send queue and POLLOUT handling
Maintain an outbox map (fd -> pending bytes). Only enable POLLOUT when there’s pending data; flush on writable; handle partial sends.
Registration and CAP flow (complete the handshake) 5) Extend Client/src/Client.cpp with registration state

Flags: passOk, hasNick, hasUser, registered; plus realname. Add getters/setters.
Finish handling of USER in Server::performHandshake
Parse “USER <user> 0 * :<realname>”, set Client::setUsername, store realname, mark hasUser.
Enforce registration rules in Server.cpp
Before registered, allow only PASS/NICK/USER/CAP/PING; once passOk+hasNick+hasUser -> registered.
On registration completion, send welcome numerics 001–004 (build with a small reply formatter). Do not send CLIENT_CONNECTED.
Minimal CAP replies in Server::performHandshake
CAP LS: advertise none (you already send “CAP * LS :”); CAP REQ: NAK; CAP END: proceed with registration.
Identity and validation 9) Nickname validation and uniqueness

Keep a nick->fd map; on duplicate nick, send 433 (ERR_NICKNAMEINUSE). Validate charset/length.
Hostmask/prefix formatting
Standardize reply prefix as “:HAI”; centralize numerics/text in Constants.hpp.
Command dispatcher (replace the “handshake” special-case) 11) Introduce a line parser + dispatcher called from the read loop in Server.cpp

Split: prefix (optional), command, params, trailing. Route to handlers.
Convert current Server::performHandshake into specific handlers: PASS/NICK/USER/CAP; add handlers for others below.
Core IRC commands (minimal set to meet the subject) 12) Connection and liveness

PING -> PONG; QUIT (cleanup; notify channels once you have them).
Messaging
PRIVMSG and NOTICE to users (by nick map). Channel targets will come after channels exist.
Channels (basic)
Add Channel abstraction (file and map): members, operators, topic, key, limit, inviteOnly, invited list.
Implement JOIN (create if missing), PART, NAMES, and broadcast to channel members.
Operator and mode features
TOPIC (respect +t), MODE for channels: +i, +t, +k <key>, +o <nick>, +l <count> (and removals), INVITE, KICK.
Event loop and robustness polish 16) Respect 512-byte IRC message limit (including CRLF) when reading and writing.
17) Case-insensitive comparisons for commands/channel names (RFC1459 mapping).
18) Graceful shutdown: handle SIGINT/SIGTERM to flip Server::isRunning and exit the loop cleanly.
19) Logging: reduce poll timeout spam in Server.cpp; keep errors and important state transitions.
20) Fix typos in Constants.hpp strings (INITALIZAE_SERVER, SERVER_CABAILITY) to avoid mismatches.

Build and organization 21) Split responsibilities

Keep Server::start focused on I/O and event dispatch; move protocol logic into dedicated functions/files.
Update Makefile when adding new .cpp/.hpp files.
Quick test plan (using your reference client)

PASS (wrong -> 464 and disconnect; correct -> proceed); NICK; USER; ensure 001–004 welcome after registration.
PING/PONG; QUIT cleanup.
PRIVMSG user->user.
JOIN/PRIVMSG channel broadcast; NAMES; PART.
Channel ops: set +i/+t/+k/+l; INVITE; KICK; TOPIC with/without +t.
Disconnect during send and partial read/write cases.
Where to make the first changes

Non-blocking accept sockets + poll error handling in Server.cpp inside Server::start.
Recv safety and EOF handling in Server::recieveData with implementation in Server.cpp.
Registration state in Client/src/Client.cpp.
Replace/extend Server::performHandshake into proper PASS/NICK/USER/CAP handlers and a general dispatcher.
Centralize numeric/reply strings in Constants.hpp.
Keep the entry point main.cpp as-is; add signal handling later.